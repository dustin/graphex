-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/dustin/graphex#readme</a>
@package graphex
@version 0.1.0.0

module Graphex.Core
newtype Graph a
Graph :: Map a (Set a) -> Graph a
[unGraph] :: Graph a -> Map a (Set a)
singletonGraph :: Ord a => a -> a -> Graph a
mkGraph :: Ord a => a -> [a] -> Graph a
data Import
Import :: ModuleName -> Maybe Text -> Import
[module_] :: Import -> ModuleName
[package] :: Import -> Maybe Text
newtype ModuleName
ModuleName :: Text -> ModuleName
[unModuleName] :: ModuleName -> Text
data Module
Module :: ModuleName -> FilePath -> Module
[name] :: Module -> ModuleName
[path] :: Module -> FilePath
type ModuleGraph = Graph ModuleName
singletonModuleGraph :: ModuleName -> ModuleName -> ModuleGraph
mkModuleGraph :: ModuleName -> [ModuleName] -> ModuleGraph

-- | Convert a Graph of type <tt>a</tt> to a Graph of type <tt>b</tt>. This
--   is like a functor, but it can't be a functor because of laws and
--   stuff.
convertGraph :: Ord b => (a -> b) -> Graph a -> Graph b
instance GHC.Classes.Eq a => GHC.Classes.Eq (Graphex.Core.Graph a)
instance GHC.Show.Show Graphex.Core.ModuleName
instance Data.String.IsString Graphex.Core.ModuleName
instance GHC.Classes.Ord Graphex.Core.ModuleName
instance GHC.Classes.Eq Graphex.Core.ModuleName
instance GHC.Show.Show Graphex.Core.Import
instance GHC.Show.Show Graphex.Core.Module
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Graphex.Core.Graph a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Graphex.Core.Graph a)

module Graphex.CSV
data Edge
Edge :: Text -> Text -> Edge
[from] :: Edge -> Text
[to] :: Edge -> Text
toEdges :: Graph Text -> [Edge]
instance Data.Csv.Conversion.ToNamedRecord Graphex.CSV.Edge
instance Data.Csv.Conversion.ToRecord Graphex.CSV.Edge
instance Data.Csv.Conversion.DefaultOrdered Graphex.CSV.Edge
instance GHC.Generics.Generic Graphex.CSV.Edge
instance GHC.Show.Show Graphex.CSV.Edge
instance GHC.Classes.Eq Graphex.CSV.Edge

module Graphex.LookingGlass
data Node
Node :: Text -> Maybe Text -> Node
[label] :: Node -> Text
[color] :: Node -> Maybe Text
type NodeId = Text
data Edge
Edge :: NodeId -> NodeId -> Edge
[from] :: Edge -> NodeId
[to] :: Edge -> NodeId
data GraphDef
GraphDef :: Text -> Map NodeId Node -> [Edge] -> GraphDef
[title] :: GraphDef -> Text
[nodes] :: GraphDef -> Map NodeId Node
[edges] :: GraphDef -> [Edge]
newtype Color
Color :: Text -> Color
[unColor] :: Color -> Text
red :: Color
black :: Color
toLookingGlass :: Text -> Map ModuleName Color -> ModuleGraph -> GraphDef
instance Data.Aeson.Types.ToJSON.ToJSON Graphex.LookingGlass.Node
instance Data.Aeson.Types.FromJSON.FromJSON Graphex.LookingGlass.Node
instance GHC.Generics.Generic Graphex.LookingGlass.Node
instance GHC.Show.Show Graphex.LookingGlass.Node
instance Data.Aeson.Types.ToJSON.ToJSON Graphex.LookingGlass.Edge
instance Data.Aeson.Types.FromJSON.FromJSON Graphex.LookingGlass.Edge
instance GHC.Generics.Generic Graphex.LookingGlass.Edge
instance GHC.Show.Show Graphex.LookingGlass.Edge
instance Data.Aeson.Types.ToJSON.ToJSON Graphex.LookingGlass.GraphDef
instance Data.Aeson.Types.FromJSON.FromJSON Graphex.LookingGlass.GraphDef
instance GHC.Generics.Generic Graphex.LookingGlass.GraphDef
instance GHC.Show.Show Graphex.LookingGlass.GraphDef
instance Data.String.IsString Graphex.LookingGlass.Color
instance GHC.Show.Show Graphex.LookingGlass.Color
instance GHC.Classes.Ord Graphex.LookingGlass.Color
instance GHC.Classes.Eq Graphex.LookingGlass.Color


-- | Implements a very crude Haskell import parser.
--   
--   All it does is parse full module names that are imported in a file,
--   ignoring false positives.
--   
--   It does not use CPP, so all conditional imports are parsed out. For
--   graphex, this makes sense in a way - those are all still dependencies.
module Graphex.Parser
importParser :: MonadParsec e s m => Token s ~ Char => IsString (Tokens s) => m Import
importsParser :: MonadParsec e s m => Token s ~ Char => IsString (Tokens s) => m [Import]
parseFileImports :: FilePath -> IO [Import]

module Graphex.Cabal
discoverCabalModules :: FilePath -> IO [Module]
discoverCabalModuleGraph :: IO ModuleGraph

module Graphex.Search

-- | A BFS that will return a list of all reachable states.
--   
--   The first argument is a representation function is used to deduplicate
--   state. For some use cases where the entire state is valid, you can use
--   <a>id</a>.
bfsOn :: Ord r => (a -> r) -> (a -> [a]) -> a -> [a]

-- | BFS with custom functions for remembering and recalling whether a
--   state has been visited.
bfsWith :: Monoid s => (a -> s -> s) -> (a -> s -> Bool) -> (a -> [a]) -> a -> [a]

-- | A DFS variant of <a>bfsOn</a>.
dfsOn :: Ord r => (a -> r) -> (a -> [a]) -> a -> [a]

-- | A DFS variant of <a>bfsWith</a>.
dfsWith :: Monoid s => (a -> s -> s) -> (a -> s -> Bool) -> (a -> [a]) -> a -> [a]

-- | Find the first match using the given search function (e.g.,
--   <a>bfsOn</a> or <a>dfsOn</a>).
findFirst :: Ord r => SearchFunction r a -> (a -> r) -> (a -> [a]) -> a -> (a -> Bool) -> Maybe a

-- | Flood fill a graph from a starting point and return all visited
--   points.
flood :: Ord a => (a -> Set a) -> a -> Set a

module Graphex
newtype Graph a
Graph :: Map a (Set a) -> Graph a
[unGraph] :: Graph a -> Map a (Set a)

-- | Reverse all the arrows in the graphs.
reverseEdges :: Ord a => Graph a -> Graph a

-- | Find the direct list of things that are referencing this module.
directDepsOn :: Ord a => Graph a -> a -> Set a

-- | Flood fill to find all transitive dependencies on a starting module,
--   excluding the original key.
allDepsOn :: Ord a => Graph a -> a -> Set a

-- | Find an example path between two modules.
--   
--   This is a short path, but the important part is that it represents how
--   connectivy works.
why :: Ord a => Graph a -> a -> a -> [a]

-- | Count the number of transitive dependencies for each module.
rankings :: (NFData a, Ord a) => Graph a -> Map a Int

-- | Find all paths between two modules as a restricted graph of the
--   intersection of reachable nodes from the start and to the end.
allPathsTo :: (NFData a, Ord a) => Graph a -> a -> a -> Graph a

-- | Restrict a graph to only the given set of modules.
restrictTo :: (Ord a, NFData a) => Graph a -> Set a -> Graph a

-- | Visit each node in the graph and apply a function to it.
mapMaybeWithKey :: (NFData a, NFData g) => (g -> Maybe a) -> Graph g -> [(g, a)]

-- | Convert a graph back to our dependency file format.
graphToDep :: Graph Text -> GraphDef

-- | Convert a dependency file to a graph.
depToGraph :: GraphDef -> Graph Text

-- | Convert a Graph to a Tree. If there is a cycle, treat the cycle point
--   as a leaf.
graphToTree :: Ord a => a -> Graph a -> Tree a
